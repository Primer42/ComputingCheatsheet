\section{Sorting}

\begin{longtabu}{|p{2cm} | p{3cm} | p{1cm} | p{1cm} | p{1cm} | p{3cm}|}

\bf{Name} & \bf{Description} & \bf{Avg Time} & \bf{Worst Time} & \bf{Worst Space} &  \bf{Picture and/or Pseudocode} \\

\hline

Depth First Search (DFS) 
& Search as far down each branch before backtracking.
 & - & $O(|E|+|V|)$ & $O(|V|)$ & 
\tableincludegraphics{3cm}{200px-Depth-first-tree.png}
 \\ \hline
Breadth First Search (BFS) & (a) visit and inspect a node of a graph; (b) gain access to visit the nodes that neighbor the currently visited node. & - & $O(|E|+|V|)$ & $O(|V|) $ &
\tableincludegraphics{3cm}{200px-Breadth-first-tree.png}
\\ \hline
Binary Search & In each step, the algorithm compares the input key value with the key value of the middle element of the array. If the keys match, then a matching element has been found so its index, or position, is returned. Otherwise, if the sought key is less than the middle element's key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the input key is greater, on the sub-array to the right. If the remaining array to be searched is reduced to zero, then the key cannot be found in the array and a special "Not found" indication is returned.

A binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm. & $O(log n)$ & $O(log n)$ & $O(1)$ &

\lstinputlisting[language=C]{binary_search.txt}

\\ \hline

more text here & & & & & \\

\end{longtabu}